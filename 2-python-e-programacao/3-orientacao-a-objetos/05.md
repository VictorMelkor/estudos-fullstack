# üîê Getters, Setters e @property em Python

Em programa√ß√£o orientada a objetos, o **encapsulamento** consiste em esconder detalhes internos de uma classe, expondo apenas o que for necess√°rio.  
Em Python, podemos controlar o acesso e a modifica√ß√£o de atributos usando os **m√©todos especiais** `getter` e `setter`, junto com o decorador `@property`.

---

## üìå Acesso direto x controle com m√©todos

Por padr√£o, atributos em Python s√£o p√∫blicos:

```python
class Pessoa:
    def __init__(self, nome):
        self.nome = nome

p = Pessoa("Victor")
print(p.nome)  # Acesso direto
```
Mas isso n√£o nos permite:

- Validar o valor
- Impedir altera√ß√µes indevidas
- Calcular valores derivados

## üîç `@property` ‚Äî criando um getter
O decorador `@property` permite que um m√©todo se comporte como um atributo de leitura:
```python
class Produto:
    def __init__(self, preco):
        self._preco = preco  # conven√ß√£o: underline indica "protegido"

    @property
    def preco(self):
        return self._preco
```

Uso:
```python
p = Produto(100)
print(p.preco)  # Sem par√™nteses! Parece atributo, mas chama um m√©todo
```

## üîß `@atributo.setter` ‚Äî criando um setter
Permite modificar o atributo com l√≥gica adicional (valida√ß√£o, log, etc).
```python
class Produto:
    def __init__(self, preco):
        self._preco = preco

    @property
    def preco(self):
        return self._preco

    @preco.setter
    def preco(self, valor):
        if valor < 0:
            raise ValueError("O pre√ßo n√£o pode ser negativo.")
        self._preco = valor
```
Uso:
```python
p = Produto(100)
p.preco = 80     # setter chamado
print(p.preco)   # 80
p.preco = -10    # ValueError
```

## üìô Por que usar `@property`?

O decorador `@property` permite transformar m√©todos em atributos, tornando o c√≥digo mais claro, controlado e seguro.  
Ele √© usado principalmente para aplicar l√≥gica no acesso ou modifica√ß√£o de atributos, sem alterar a forma como eles s√£o utilizados.

| ‚úÖ Vantagem                          | üí¨ Explica√ß√£o                                                  |
|-------------------------------------|-----------------------------------------------------------------|
| **Encapsulamento**                  | Esconde a l√≥gica interna e protege dados sens√≠veis.             |
| **Valida√ß√£o de dados**              | Permite verificar, corrigir ou bloquear valores inv√°lidos.      |
| **Interface limpa**                 | Permite usar `obj.atributo` ao inv√©s de `obj.get_atributo()`.   |
| **Compatibilidade com c√≥digo antigo** | Voc√™ pode trocar um atributo direto por um m√©todo sem quebrar nada. |
| **Leitura e escrita controladas**   | Pode ter somente leitura (getter) ou leitura + escrita (setter). |


## ‚úèÔ∏è Exemplo completo
```python
class ContaBancaria:
    def __init__(self, saldo_inicial):
        self._saldo = saldo_inicial

    @property
    def saldo(self):
        return self._saldo

    @saldo.setter
    def saldo(self, valor):
        if valor < 0:
            raise ValueError("Saldo n√£o pode ser negativo.")
        self._saldo = valor

c = ContaBancaria(500)
print(c.saldo)     # 500
c.saldo = 1000     # ok
c.saldo = -20      # ValueError
```

## üö´ Evite:
- Criar getters e setters desnecess√°rios se n√£o h√° l√≥gica extra.
- Usar `@property` sem motivo ‚Äî s√≥ encapsule quando realmente for √∫til.
