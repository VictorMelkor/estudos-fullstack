# ğŸ§­ `self` e Encapsulamento em Python

## ğŸ”¹ O que Ã© `self`?

O `self` Ã© uma **referÃªncia ao prÃ³prio objeto da classe**.  
Toda vez que vocÃª define um mÃ©todo dentro da classe, o primeiro parÃ¢metro Ã© `self`, mesmo que vocÃª nÃ£o o passe ao chamar o mÃ©todo.

### Exemplo:

```python
class Pessoa:
    def __init__(self, nome):
        self.nome = nome  # atribuiÃ§Ã£o de atributo ao prÃ³prio objeto

    def falar(self):
        print(f"Meu nome Ã© {self.nome}")
```
Uso:
```python
p = Pessoa("Victor")
p.falar()  # Meu nome Ã© Victor
```

- `self.nome` acessa o atributo do prÃ³prio objeto.

- Ao chamar `p.falar()`, Python executa internamente: `Pessoa.falar(p)`.

---
# ğŸ”’ Encapsulamento
Encapsulamento Ã© o princÃ­pio de proteger o acesso direto aos dados internos do objeto.
Em Python, tudo Ã© pÃºblico por padrÃ£o, mas existem convenÃ§Ãµes para simular nÃ­veis de acesso.

## ğŸ”¸ PÃºblico (sem underscore)
Pode ser acessado livremente.

```python
class Conta:
    def __init__(self, saldo):
        self.saldo = saldo

c = Conta(100)
print(c.saldo)  # Acesso direto permitido
```
## ğŸ”¸ Protegido (_um_underscore)
Por convenÃ§Ã£o, nÃ£o deve ser acessado diretamente fora da classe ou subclasses.
```python
class Conta:
    def __init__(self):
        self._limite = 500  # protegido

# Ainda acessÃ­vel, mas desaconselhado
c = Conta()
print(c._limite)
```

## ğŸ”¸ Privado (__dois_underscores)
Python realiza name mangling, mudando o nome internamente (`_Classe__atributo`), dificultando o acesso.

```python
class Conta:
    def __init__(self):
        self.__senha = "1234"

c = Conta()
# print(c.__senha) â†’ erro
print(c._Conta__senha)  # Acesso forÃ§ado, nÃ£o recomendado
```

## ğŸ“Œ Boas PrÃ¡ticas
Use `self.atributo` para definir e acessar atributos de instÃ¢ncia.

Use `_atributo` para indicar que algo nÃ£o deve ser acessado diretamente.

Use `__atributo` apenas quando realmente quiser esconder detalhes internos.

Prefira controlar o acesso via mÃ©todos pÃºblicos (`getters` e `setters`).